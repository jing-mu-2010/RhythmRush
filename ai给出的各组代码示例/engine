/* game_engine.c - 游戏核心逻辑 */
#include "common.h"

// 定义内部结构体 (豆豆)
typedef struct {
    int x, y, r;
    int active;
} Bean;

// 定义内部结构体 (主角)
typedef struct {
    int x, y, w, h;
    float vy; // 垂直速度
    int isJumping;
} Player;

// 障碍物结构
typedef struct {
    int x, y, w, h;
    int active;
} Obstacle;

void RunGame(GameConfig* config, int playerType) {
    // 1. 游戏初始化
    int score = 0;
    int isPaused = 0;
    int gameOver = 0;

    // 主角属性
    Player p = { 100, GROUND_Y - 40, 40, 40, 0, 0 };
    
    // 障碍物 (简单的单个障碍物循环)
    Obstacle obs = { WIN_WIDTH, GROUND_Y - 40, 30, 40, 1 };
    
    // 豆豆数组 (5个)
    Bean beans[5];
    for(int i=0; i<5; i++) beans[i].active = 0;

    // 根据配置设置背景
    if (config->themeColor == 0) setbkcolor(RGB(50, 100, 50)); // 绿
    else if (config->themeColor == 1) setbkcolor(RGB(50, 50, 100)); // 蓝
    else setbkcolor(RGB(100, 50, 50)); // 红
    
    // 播放音乐
    // PlayBGM(config->bgmPath); // 暂时注释，防止没素材报错

    BeginBatchDraw(); // 开启双缓冲

    while (!gameOver) {
        // --- 输入处理 ---
        if (GetAsyncKeyState('P') & 0x8000) {
            isPaused = !isPaused;
            if(isPaused) Audio_Pause(); else Audio_Resume();
            Sleep(200);
        }

        if (isPaused) {
            settextcolor(WHITE);
            settextstyle(50, 0, "黑体");
            outtextxy(300, 250, "PAUSED");
            FlushBatchDraw();
            continue; // 暂停时不更新物理
        }

        // 跳跃 (空格)
        if (GetAsyncKeyState(VK_SPACE) & 0x8000) {
            if (!p.isJumping) {
                p.vy = -18.0f; // 起跳力度
                p.isJumping = 1;
            }
        }

        // --- 物理更新 ---
        // 1. 重力 (读取配置的 gravity)
        p.vy += (float)config->gravity * 0.5f; // 简单模拟
        p.y += (int)p.vy;

        // 地面检测
        if (p.y >= GROUND_Y - p.h) {
            p.y = GROUND_Y - p.h;
            p.vy = 0;
            p.isJumping = 0;
        }

        // 2. 障碍物移动 (速度由配置决定)
        obs.x -= config->speed / 100;
        if (obs.x < -50) {
            obs.x = WIN_WIDTH + rand() % 200;
            score++; // 躲避加分
        }

        // 3. 豆豆生成与移动
        if (rand() % 100 < 3) { // 3%概率生成
            for(int i=0; i<5; i++) {
                if(!beans[i].active) {
                    beans[i].x = WIN_WIDTH;
                    beans[i].y = GROUND_Y - 20 - (rand()%2)*80; // 地面或空中
                    beans[i].r = 10;
                    beans[i].active = 1;
                    break;
                }
            }
        }
        for(int i=0; i<5; i++) {
            if(beans[i].active) {
                beans[i].x -= config->speed / 100; // 和障碍物同速
                if(beans[i].x < -20) beans[i].active = 0;
                
                // 吃豆碰撞 (简单矩形判断)
                if (abs(p.x - beans[i].x) < 30 && abs(p.y - beans[i].y) < 30) {
                    beans[i].active = 0;
                    score += 5; // 吃豆加分
                }
            }
        }

        // 4. 死亡碰撞
        if (p.x + p.w > obs.x && p.x < obs.x + obs.w &&
            p.y + p.h > obs.y && p.y < obs.y + obs.h) {
            gameOver = 1;
        }

        // --- 绘图 ---
        cleardevice();
        
        // 画地平线
        setlinecolor(WHITE);
        line(0, GROUND_Y, WIN_WIDTH, GROUND_Y);

        // 画豆豆
        setfillcolor(YELLOW);
        setlinecolor(YELLOW);
        for(int i=0; i<5; i++) {
            if(beans[i].active) fillcircle(beans[i].x, beans[i].y, beans[i].r);
        }

        // 画障碍物
        setfillcolor(LIGHTGRAY);
        setlinecolor(WHITE);
        fillrectangle(obs.x, obs.y, obs.x + obs.w, obs.y + obs.h);

        // 画主角 (根据 playerType 变身)
        if (playerType == 1) { // 蓝方块
            setfillcolor(BLUE);
            fillrectangle(p.x, p.y, p.x + p.w, p.y + p.h);
        } else if (playerType == 2) { // 红球
            setfillcolor(RED);
            fillcircle(p.x + 20, p.y + 20, 20);
        } else { // 绿方块
            setfillcolor(GREEN);
            fillrectangle(p.x, p.y, p.x + p.w, p.y + p.h);
        }

        // 画分数
        char scoreText[50];
        sprintf(scoreText, "Score: %d", score);
        settextcolor(WHITE);
        settextstyle(20, 0, "Arial");
        outtextxy(10, 10, scoreText);

        FlushBatchDraw();
        Sleep(16);
    }
    EndBatchDraw();

    // 结算画面
    MessageBox(GetHWnd(), "游戏结束！", "Game Over", MB_OK);
}